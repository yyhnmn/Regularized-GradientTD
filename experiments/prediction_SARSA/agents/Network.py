import torch
import torch.nn as nn
import torch.nn.functional as f

class Network(nn.Module):
    def __init__(self, input_size, h1_size, h2_size, output_size):
        super(Network, self).__init__()
        self.input_size = input_size
        self.h1_size = h1_size
        self.h2_size = h2_size
        self.output_size = output_size

        self.fc_1 = nn.Linear(self.input_size, self.h1_size, bias=True)
        self.fc_2 = nn.Linear(self.h1_size, self.h2_size, bias=True)
        self.fc_out = nn.Linear(self.h2_size, self.output_size, bias=True)

        self.init_weights()

    def init_weights(self):
        for layer in self.children():
            nn.init.xavier_uniform_(layer.weight.data)
            nn.init.normal_(layer.bias.data, 0, 0.1)

    def forward(self, x):
        x = f.relu(self.fc_1(x))
        features = f.relu(self.fc_2(x))

        # give back both the outputs of the Q network
        # and the "features" generated by the second to last layer
        return self.fc_out(features), features

    def cloneWeightsTo(self, toNet):
        toNet.load_state_dict(self.state_dict())
